{"version":3,"sources":["../../src/index.ts","../../src/api/session-token.ts"],"sourcesContent":["import type { NextRequest } from \"next/server\";\nimport { NextResponse } from \"next/server\";\nimport { Address, getAddress } from \"viem\";\nimport type { Address as SolanaAddress } from \"@solana/kit\";\nimport { exact } from \"x402/schemes\";\nimport {\n  computeRoutePatterns,\n  findMatchingPaymentRequirements,\n  findMatchingRoute,\n  processPriceToAtomicAmount,\n  toJsonSafe,\n} from \"x402/shared\";\nimport { getPaywallHtml } from \"x402/paywall\";\nimport {\n  FacilitatorConfig,\n  moneySchema,\n  PaymentPayload,\n  PaymentRequirements,\n  Resource,\n  RoutesConfig,\n  PaywallConfig,\n  ERC20TokenAmount,\n  SupportedEVMNetworks,\n  SupportedSVMNetworks,\n} from \"x402/types\";\nimport { useFacilitator } from \"x402/verify\";\nimport { safeBase64Encode } from \"x402/shared\";\n\nimport { POST } from \"./api/session-token\";\n\n/**\n * Creates a payment middleware factory for Next.js\n *\n * @param payTo - The address to receive payments\n * @param routes - Configuration for protected routes and their payment requirements\n * @param facilitator - Optional configuration for the payment facilitator service\n * @param paywall - Optional configuration for the default paywall\n * @returns A Next.js middleware handler\n *\n * @example\n * ```typescript\n * // Simple configuration - All endpoints are protected by $0.01 of USDC on somnia-testnet\n * export const middleware = paymentMiddleware(\n *   '0x123...', // payTo address\n *   {\n *     price: '$0.01', // USDC amount in dollars\n *     network: 'somnia-testnet'\n *   },\n *   // Optional facilitator configuration. Defaults to x402.org/facilitator for testnet usage\n * );\n *\n * // Advanced configuration - Endpoint-specific payment requirements & custom facilitator\n * export const middleware = paymentMiddleware(\n *   '0x123...', // payTo: The address to receive payments\n *   {\n *     '/protected/*': {\n *       price: '$0.001', // USDC amount in dollars\n *       network: 'base',\n *       config: {\n *         description: 'Access to protected content'\n *       }\n *     },\n *     '/api/premium/*': {\n *       price: {\n *         amount: '100000',\n *         asset: {\n *           address: '0xabc',\n *           decimals: 18,\n *           eip712: {\n *             name: 'WETH',\n *             version: '1'\n *           }\n *         }\n *       },\n *       network: 'base'\n *     }\n *   },\n *   {\n *     url: 'https://facilitator.example.com',\n *     createAuthHeaders: async () => ({\n *       verify: { \"Authorization\": \"Bearer token\" },\n *       settle: { \"Authorization\": \"Bearer token\" }\n *     })\n *   },\n *   {\n *     cdpClientKey: 'your-cdp-client-key',\n *     appLogo: '/images/logo.svg',\n *     appName: 'My App',\n *   }\n * );\n * ```\n */\nexport function paymentMiddleware(\n  payTo: Address | SolanaAddress,\n  routes: RoutesConfig,\n  facilitator?: FacilitatorConfig,\n  paywall?: PaywallConfig,\n) {\n  const { verify, settle, supported } = useFacilitator(facilitator);\n  const x402Version = 1;\n\n  // Pre-compile route patterns to regex and extract verbs\n  const routePatterns = computeRoutePatterns(routes);\n\n  return async function middleware(request: NextRequest) {\n    const pathname = request.nextUrl.pathname;\n    const method = request.method.toUpperCase();\n\n    // Find matching route configuration\n    const matchingRoute = findMatchingRoute(routePatterns, pathname, method);\n\n    if (!matchingRoute) {\n      return NextResponse.next();\n    }\n\n    const { price, network, config = {} } = matchingRoute.config;\n    const {\n      description,\n      mimeType,\n      maxTimeoutSeconds,\n      inputSchema,\n      outputSchema,\n      customPaywallHtml,\n      resource,\n      errorMessages,\n      discoverable,\n    } = config;\n\n    const atomicAmountForAsset = processPriceToAtomicAmount(price, network);\n    if (\"error\" in atomicAmountForAsset) {\n      return new NextResponse(atomicAmountForAsset.error, { status: 500 });\n    }\n    const { maxAmountRequired, asset } = atomicAmountForAsset;\n\n    const resourceUrl =\n      resource || (`${request.nextUrl.protocol}//${request.nextUrl.host}${pathname}` as Resource);\n\n    let paymentRequirements: PaymentRequirements[] = [];\n\n    // TODO: create a shared middleware function to build payment requirements\n    // evm networks\n    if (SupportedEVMNetworks.includes(network)) {\n      paymentRequirements.push({\n        scheme: \"exact\",\n        network,\n        maxAmountRequired,\n        resource: resourceUrl,\n        description: description ?? \"\",\n        mimeType: mimeType ?? \"application/json\",\n        payTo: getAddress(payTo),\n        maxTimeoutSeconds: maxTimeoutSeconds ?? 300,\n        asset: getAddress(asset.address),\n        // TODO: Rename outputSchema to requestStructure\n        outputSchema: {\n          input: {\n            type: \"http\",\n            method,\n            discoverable: discoverable ?? true,\n            ...inputSchema,\n          },\n          output: outputSchema,\n        },\n        extra: (asset as ERC20TokenAmount[\"asset\"]).eip712,\n      });\n    }\n    // svm networks\n    else if (SupportedSVMNetworks.includes(network)) {\n      // network call to get the supported payments from the facilitator\n      const paymentKinds = await supported();\n\n      // find the payment kind that matches the network and scheme\n      let feePayer: string | undefined;\n      for (const kind of paymentKinds.kinds) {\n        if (kind.network === network && kind.scheme === \"exact\") {\n          feePayer = kind?.extra?.feePayer;\n          break;\n        }\n      }\n\n      // svm networks require a fee payer\n      if (!feePayer) {\n        throw new Error(`The facilitator did not provide a fee payer for network: ${network}.`);\n      }\n\n      // build the payment requirements for svm\n      paymentRequirements.push({\n        scheme: \"exact\",\n        network,\n        maxAmountRequired,\n        resource: resourceUrl,\n        description: description ?? \"\",\n        mimeType: mimeType ?? \"\",\n        payTo: payTo,\n        maxTimeoutSeconds: maxTimeoutSeconds ?? 60,\n        asset: asset.address,\n        // TODO: Rename outputSchema to requestStructure\n        outputSchema: {\n          input: {\n            type: \"http\",\n            method,\n            discoverable: discoverable ?? true,\n            ...inputSchema,\n          },\n          output: outputSchema,\n        },\n        extra: {\n          feePayer,\n        },\n      });\n    } else {\n      throw new Error(`Unsupported network: ${network}`);\n    }\n\n    // Check for payment header\n    const paymentHeader = request.headers.get(\"X-PAYMENT\");\n    if (!paymentHeader) {\n      const accept = request.headers.get(\"Accept\");\n      if (accept?.includes(\"text/html\")) {\n        const userAgent = request.headers.get(\"User-Agent\");\n        if (userAgent?.includes(\"Mozilla\")) {\n          let displayAmount: number;\n          if (typeof price === \"string\" || typeof price === \"number\") {\n            const parsed = moneySchema.safeParse(price);\n            if (parsed.success) {\n              displayAmount = parsed.data;\n            } else {\n              displayAmount = Number.NaN;\n            }\n          } else {\n            displayAmount = Number(price.amount) / 10 ** price.asset.decimals;\n          }\n\n          // TODO: handle paywall html for solana\n          const html =\n            customPaywallHtml ??\n            getPaywallHtml({\n              amount: displayAmount,\n              paymentRequirements: toJsonSafe(paymentRequirements) as Parameters<\n                typeof getPaywallHtml\n              >[0][\"paymentRequirements\"],\n              currentUrl: request.url,\n              testnet: network === \"somnia-testnet\",\n              cdpClientKey: paywall?.cdpClientKey,\n              appLogo: paywall?.appLogo,\n              appName: paywall?.appName,\n              sessionTokenEndpoint: paywall?.sessionTokenEndpoint,\n            });\n          return new NextResponse(html, {\n            status: 402,\n            headers: { \"Content-Type\": \"text/html\" },\n          });\n        }\n      }\n\n      return new NextResponse(\n        JSON.stringify({\n          x402Version,\n          error: errorMessages?.paymentRequired || \"X-PAYMENT header is required\",\n          accepts: paymentRequirements,\n        }),\n        { status: 402, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n\n    // Verify payment\n    let decodedPayment: PaymentPayload;\n    try {\n      decodedPayment = exact.evm.decodePayment(paymentHeader);\n      decodedPayment.x402Version = x402Version;\n    } catch (error) {\n      return new NextResponse(\n        JSON.stringify({\n          x402Version,\n          error:\n            errorMessages?.invalidPayment || (error instanceof Error ? error : \"Invalid payment\"),\n          accepts: paymentRequirements,\n        }),\n        { status: 402, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n\n    const selectedPaymentRequirements = findMatchingPaymentRequirements(\n      paymentRequirements,\n      decodedPayment,\n    );\n    if (!selectedPaymentRequirements) {\n      return new NextResponse(\n        JSON.stringify({\n          x402Version,\n          error:\n            errorMessages?.noMatchingRequirements || \"Unable to find matching payment requirements\",\n          accepts: toJsonSafe(paymentRequirements),\n        }),\n        { status: 402, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n\n    const verification = await verify(decodedPayment, selectedPaymentRequirements);\n\n    if (!verification.isValid) {\n      return new NextResponse(\n        JSON.stringify({\n          x402Version,\n          error: errorMessages?.verificationFailed || verification.invalidReason,\n          accepts: paymentRequirements,\n          payer: verification.payer,\n        }),\n        { status: 402, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n\n    // Proceed with request\n    const response = await NextResponse.next();\n\n    // if the response from the protected route is >= 400, do not settle the payment\n    if (response.status >= 400) {\n      return response;\n    }\n\n    // Settle payment after response\n    try {\n      const settlement = await settle(decodedPayment, selectedPaymentRequirements);\n\n      if (settlement.success) {\n        response.headers.set(\n          \"X-PAYMENT-RESPONSE\",\n          safeBase64Encode(\n            JSON.stringify({\n              success: true,\n              transaction: settlement.transaction,\n              network: settlement.network,\n              payer: settlement.payer,\n            }),\n          ),\n        );\n      }\n    } catch (error) {\n      return new NextResponse(\n        JSON.stringify({\n          x402Version,\n          error:\n            errorMessages?.settlementFailed ||\n            (error instanceof Error ? error : \"Settlement failed\"),\n          accepts: paymentRequirements,\n        }),\n        { status: 402, headers: { \"Content-Type\": \"application/json\" } },\n      );\n    }\n\n    return response;\n  };\n}\n\nexport type {\n  Money,\n  Network,\n  PaymentMiddlewareConfig,\n  Resource,\n  RouteConfig,\n  RoutesConfig,\n} from \"x402/types\";\nexport type { Address as SolanaAddress } from \"@solana/kit\";\n\n// Export session token API handlers for Onramp\nexport { POST };\n","import { generateJwt } from \"@coinbase/cdp-sdk/auth\";\nimport { NextRequest, NextResponse } from \"next/server\";\n\n/**\n * Generate a session token for Coinbase Onramp and Offramp using Secure Init\n *\n * This endpoint creates a server-side session token that can be used\n * instead of passing appId and addresses directly in onramp/offramp URLs.\n *\n * Setup:\n * 1. Set CDP_API_KEY_ID and CDP_API_KEY_SECRET environment variables\n * 2. Copy this file to: app/api/x402/session-token/route.ts\n *\n * @param request - The NextRequest containing the session token request\n * @returns Promise<NextResponse> - The response containing the session token or error\n */\nexport async function POST(request: NextRequest) {\n  try {\n    // Get CDP API credentials from environment variables\n    const apiKeyId = process.env.CDP_API_KEY_ID;\n    const apiKeySecret = process.env.CDP_API_KEY_SECRET;\n\n    if (!apiKeyId || !apiKeySecret) {\n      console.error(\"Missing CDP API credentials\");\n      return NextResponse.json(\n        { error: \"Server configuration error: Missing CDP API credentials\" },\n        { status: 500 },\n      );\n    }\n\n    // Parse request body\n    const body = (await request.json()) as {\n      addresses?: Array<{ address: string; blockchains?: string[] }>;\n      assets?: string[];\n    };\n    const { addresses, assets } = body;\n\n    if (!addresses || !Array.isArray(addresses) || addresses.length === 0) {\n      return NextResponse.json(\n        { error: \"addresses is required and must be a non-empty array\" },\n        { status: 400 },\n      );\n    }\n\n    // Generate JWT for authentication\n    const jwt = await generateJwt({\n      apiKeyId,\n      apiKeySecret,\n      requestMethod: \"POST\",\n      requestHost: \"api.developer.coinbase.com\",\n      requestPath: \"/onramp/v1/token\",\n    });\n\n    // Create session token request payload\n    const tokenRequestPayload = {\n      addresses: addresses.map((addr: { address: string; blockchains?: string[] }) => ({\n        address: addr.address,\n        blockchains: addr.blockchains || [\"base\"],\n      })),\n      ...(assets && { assets }),\n    };\n\n    // Call Coinbase API to generate session token\n    const response = await fetch(\"https://api.developer.coinbase.com/onramp/v1/token\", {\n      method: \"POST\",\n      headers: {\n        Authorization: `Bearer ${jwt}`,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(tokenRequestPayload),\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error(\"Failed to generate session token:\", response.status, errorText);\n      return NextResponse.json(\n        { error: \"Failed to generate session token\" },\n        { status: response.status },\n      );\n    }\n\n    const data = await response.json();\n\n    return NextResponse.json(data);\n  } catch (error) {\n    console.error(\"Error generating session token:\", error);\n    return NextResponse.json({ error: \"Internal server error\" }, { status: 500 });\n  }\n}\n"],"mappings":"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","names":["NextResponse","NextResponse"]}